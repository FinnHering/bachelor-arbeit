\chapter{Verwandte Arbeiten}
\label{cha:related-work}

\section{Implementation and Analysis of Container Image Optimization Using Alpine Linux and Multi-Stage Builds \cite{fachrudinImplementationAnalysisContainer2025}}

Die Arbeit "Implementation and Analysis of Container Image Optimization Using Alpine Linux and Multi-Stage Builds" beschäftigt sich mit der Optimierung von Containerimages mithilfe von mehreren Mechanismen. Die Haupt-Mechanismen sind dabei die Verwendung von Alpine Linux als Basisimage und die Verwendung von Multi-Stage Builds, um die Build-Zeit zu beschleunigen und die resultierende Image-Größe zu minimieren. 

In dieser Arbeit wurde ein ähnlicher Ansatz wie in Abbildung 2 \cite[Vgl. S. 11]{fachrudinImplementationAnalysisContainer2025} der Arbeit gewählt. Es wird wie in dieser Arbeit auch zwischen Abhängigkeits-Stages, Build-Stages und Runtime/Production-Stages unterschieden. 

\todo[inline]{Wie zitiert man eine Abbildung?}

In dieser Arbeit wurden allerdings die Abhängigkeits-Stages und die Build-Stages anders aufgebaut. Es gibt grundsätzlich immer die Runtime-Dependency-Stage und die Buildtime-Dependency-Stage, wobei die Buildtime-Abhängigkeits-Stage auf der Runtime-Abhängigkeits-Stage aufbaut, weil die Runtime-Abhängigkeiten als Obermenge der Buildtime-Abhängigkeiten in dieser Arbeit betrachtet werden können. Außerdem verwenden wir nicht Alpine als Basisimage, sondern Ubuntu, da JULEA GLib als Abhängigkeit hat und GLib nicht ohne weiteres auf Alpine installiert werden kann.

\section{Containers for computational reproducibility \cite{moreauContainersComputationalReproducibility2023}}

Die Arbeit beschäftigt sich mit der Verwendung von Containervirtualisierung in der Wissenschaft. Dabei werden die Vorteile von Containerisierung aufgezeigt \cite[Vgl. S. 4ff]{moreauContainersComputationalReproducibility2023} und die Verwendung in verschiedenen wissenschaftlichen Bereichen \cite[Vgl. S. 6ff]{moreauContainersComputationalReproducibility2023} beschrieben. Es wird sich hauptsächlich auf die Verwendung des Docker Ökosystems konzentriert, allerdings werden auch Singularity (Apptainer) und Podman vorgestellt \cite[Vgl. S. 7]{moreauContainersComputationalReproducibility2023}. Des Weiteren wird auch auf die Verwendung von Containern in HPC-Umgebungen eingegangen und domänenspezifische Probleme aufgezeigt, welche das Nutzen von Containern in HPC-Umgebungen erschweren. Eine davon sei die üblich starke Isolierung der Container \cite[Vgl. S. 12f]{moreauContainersComputationalReproducibility2023}.

Im direkten Vergleich zu dieser Arbeit wird in der Arbeit "Containers for computational reproducibility" \cite{moreauContainersComputationalReproducibility2023} wird ersichtlich, dass die Gründe und Vorteile der Containerisierung in beiden Arbeiten sich größtenteils überschneiden. Es wird das Problem der steigenden Komplexität von Software in beiden Arbeiten als ein Grund für die Verwendung von Containern genannt \cite[Vgl. S. 1]{moreauContainersComputationalReproducibility2023} und auf den starken einfluss von Abhängigkeiten auf die Reproduzierbarkeit von Software hingewiesen \cite[Vgl. S. 2]{moreauContainersComputationalReproducibility2023}. 

Im gegensatz zu der Arbeit wird in dieser Arbeit allerdings keine Übersicht über den aktuellen Stand der Containerisierung in der Wissenschaft gegeben, sondern ein konkreter Anwendungsfall betrachtet und ein Containerisierungsansatz für diesen Anwendungsfall vorgestellt.



\section{Exploring the performance of Singularity of High Performance Computing Scenarios \cite{huExploringPerformanceSingularity2019}}

In "Exploring the performance of Singularity of High Performance Computing Scenarios" wird die Performance von Singularity (Apptainer) für HPC-Szenarien mithilfe von den Benchmarks HPL (für CPU), STREAM (für Memory) und OSU Mikro-Benchmarks (für Netzwerk) gemessen und mit der nativen Performance verglichen. Außerdem werden noch Benchmarkergebnisse von 4 "typischen HPC-Anwendungen" (NAMD, VASP, AMBER und WRF) vorgestellt und verglichen \cite[Vgl. S. 2587]{huExploringPerformanceSingularity2019}. Das Ergebnis der Arbeit ist, dass Singularity so gut wie keine Performance-Einbußen habe, hochkompatibel ist und die portabilität von Applikation erhöhe \cite[Vgl. S. 2592]{huExploringPerformanceSingularity2019}.  

Beide Arbeiten sind zu der Feststellung gekommen, dass die Containerisierung von Software Vorteile wie die erhöhte Portabilität mit sich bringt und es zu kaum bis geringen Performance-Einbußen kommt \cite[Vgl. S. 2592]{huExploringPerformanceSingularity2019}. In beiden Arbeiten Benchmarks an HPC-Anwendungen durchgeführt, um die Performance von Containern in HPC-Szenarien zu messen \cite[Vgl. S. 2587]{huExploringPerformanceSingularity2019} und es wurde außerdem in beiden fällen Apptainer (Singularity) verwendet \cite[Vgl. S. 2587]{huExploringPerformanceSingularity2019}.

Im Gegensatz zu dieser Arbeit wurde in der Arbeit "Exploring the performance of Singularity of High Performance Computing Scenarios" \cite{huExploringPerformanceSingularity2019} sich nicht mit der Implementierung eines konkreten Anwendungsfalls beschäftigt, sondern die Performance von Singularity in HPC-Szenarien untersucht. Hierbei hat die Arbeit mehrere Benchmarks durchgeführt \cite[Vgl. S. 2587]{huExploringPerformanceSingularity2019}, nicht wie bei dieser Arbeit, wo nur der Implementierte Anwendungsfall betrachtet wird.  


\section{Fazit}

Es gibt bereits eine vielzahl der Arbeiten, welche sich mit der Containerisierung beschäftigen. Auch Arbeiten, welche sich explizit auf den Wissenschafts- und HPC-Bereich beschäftigen, gibt es bereits. Diese Arbeiten fokussieren sich allerdings meistens eher mit der Feststellung des aktuellen Standes der Containerisierung in der Wissenschaft und HPC \cite{moreauContainersComputationalReproducibility2023}, oder mit der Performance von Containern in HPC-Szenarien \cite{huExploringPerformanceSingularity2019}. In einigen wird sich auch mit den "best practices" für die Containerisierung von Software beschäftigt \cite{fachrudinImplementationAnalysisContainer2025}.

Allerdings gibt es bisher keine Arbeit, welche sich mit der Implementierung eines konkreten Anwendungsfalls für eine HPC-Anwendung beschäftigt und diese Benchmarked. Insbesondere gibt es keine Arbeit, welche die Verwendung von Docker Buildx Bakefiles für das Erstellen von Containerimages für HPC-Anwendungen in Betracht zieht.



