\chapter{Verwandte Arbeiten}
\label{cha:related-work}

In diesem Kapitel werden vergleichbare Ansätze und Forschungsergebnisse betrachtet, die sich mit der Containerisierung komplexer Applikationen befassen. Dabei wird der Schwerpunkt auf den praktischen Einsatz von Containervirtualisierungslösungen, wie Docker, ContainerD oder Apptainer gelegt.

In diesem Kapitel werden zuerst ähnliche Arbeiten mit dieser Arbeit verglichen und anschließend ein Fazit gezogen, um die Einzigartigkeit dieser Arbeit hervorzuheben.

\section{Implementation and Analysis of Container Image Optimization Using Alpine Linux and Multi-Stage Builds \cite{fachrudinImplementationAnalysisContainer2025}}

Die Arbeit "Implementation and Analysis of Container Image Optimization Using Alpine Linux and Multi-Stage Builds" beschäftigt sich mit der Optimierung von Containerimages mithilfe mehrerer Mechanismen. Die Hauptmechanismen sind dabei die Verwendung von Alpine Linux als Basisimage und das Nutzen von Multi-Stage Builds, um die Build-Zeit zu beschleunigen und die resultierende Image-Größe zu minimieren. 

Es wurde ein ähnlicher Ansatz wie in Abbildung 2 \cite[Vgl. S. 11]{fachrudinImplementationAnalysisContainer2025} gewählt, bei dem zwischen Abhängigkeits-Stages, Build-Stages und Runtime/Production-Stages unterschieden wird. 

In dieser Arbeit wurden allerdings die Abhängigkeits-Stages und die Build-Stages anders aufgebaut. Es gibt grundsätzlich immer die Runtime-Abhängigkeits-Stage und die Compiletime-Abhängigkeits-Stage, wobei die Compiletime-Abhängigkeits-Stage auf der Runtime-Abhängigkeits-Stage aufbaut, weil die Runtime-Abhängigkeiten als Untermenge der Buildtime-Abhängigkeiten in dieser Arbeit betrachtet werden kann. Der allgemeine Aufbau der Containerfiles dieser Arbeit wird in \cref{sec:allgemeiner-aufbau-der-dockerfiles} erläutert. 

Außerdem wird in dieser Arbeit nicht Alpine als Basisimage verwendet, sondern Ubuntu, da JULEA GLib als Abhängigkeit hat und GLib nicht ohne Weiteres auf Alpine installiert werden kann.

\section{Containers for computational reproducibility \cite{moreauContainersComputationalReproducibility2023}}

Die Arbeit "Containers for computational reproducibility" \cite{moreauContainersComputationalReproducibility2023} konzentriert sich hauptsächlich auf die Vorteile von Containervirtualisierung in der Wissenschaft \cite[Vgl. S. 4ff]{moreauContainersComputationalReproducibility2023}, untersucht verschiedene wissenschaftliche Bereiche \cite[Vgl. S. 6ff]{moreauContainersComputationalReproducibility2023} und stellt dabei auch Apptainer (Singularity) und Podman vor \cite[Vgl. S. 7]{moreauContainersComputationalReproducibility2023}. 

Des Weiteren wird auch auf die Verwendung von Containern in HPC-Umgebungen eingegangen und domänenspezifische Probleme aufgezeigt, welche das Nutzen von Containern in HPC-Umgebungen erschweren. Eine davon sei die üblich starke Isolierung der Container \cite[Vgl. S. 12f]{moreauContainersComputationalReproducibility2023}.

Im direkten Vergleich dieser Arbeit mit der Arbeit "Containers for computational reproducibility" \cite{moreauContainersComputationalReproducibility2023} wird ersichtlich, dass die genannten Gründe und Vorteile der Containerisierung in beiden Arbeiten sich größtenteils überschneiden. Es wird das Problem der steigenden Komplexität von Software in beiden Arbeiten als Grund für die Verwendung von Containern genannt und auf den starken Einfluss von Abhängigkeiten hingewiesen \cite[Vgl. S. 1f]{moreauContainersComputationalReproducibility2023}. 

Im Gegensatz zu der Arbeit "Containers for computational reproducibility" wird in dieser Arbeit allerdings keine Übersicht über den aktuellen Stand der Containerisierung in der Wissenschaft gegeben, sondern ein konkreter Anwendungsfall betrachtet und ein Containerisierungsansatz für diesen Anwendungsfall implementiert und evaluiert.

\section{Exploring the performance of Singularity of High Performance Computing Scenarios \cite{huExploringPerformanceSingularity2019}}

In "Exploring the performance of Singularity of High Performance Computing Scenarios" \cite{huExploringPerformanceSingularity2019} wird die Performance von Apptainer (Singularity) für HPC-Szenarien mithilfe von Benchmarks wie HPL (für CPU), STREAM (für Memory) und OSU Mikro-Benchmarks (für Netzwerk) gemessen und mit der nativen Performance verglichen \cite[Vgl. S. 2587]{huExploringPerformanceSingularity2019}. 

Außerdem werden noch Benchmarkergebnisse von 4 "typischen HPC-Anwendungen" (NAMD, VASP, AMBER und WRF) vorgestellt und verglichen \cite[Vgl. S. 2587]{huExploringPerformanceSingularity2019}. Das Ergebnis der Arbeit ist, dass Singularity so gut wie keine Performance-Einbußen habe, hochkompatibel sei und die Portabilität von Applikationen erhöhe \cite[Vgl. S. 2592]{huExploringPerformanceSingularity2019}.  

Beide Arbeiten gelangen zu der Erkenntnis, dass Containerisierung Vorteile wie höhere Portabilität bietet und nur geringe Performance-Verluste verursacht. In beiden Arbeiten wurden Benchmarks an HPC-Anwendungen durchgeführt, um die Performance von Containern in HPC-Szenarien zu messen \cite[Vgl. S. 2587]{huExploringPerformanceSingularity2019} und es wurde außerdem in beiden Fällen Apptainer (Singularity) verwendet \cite[Vgl. S. 2587]{huExploringPerformanceSingularity2019}.

Im Gegensatz zu dieser Arbeit wurde in der Arbeit "Exploring the performance of Singularity of High Performance Computing Scenarios" \cite{huExploringPerformanceSingularity2019} sich nicht mit der Implementierung eines konkreten Anwendungsfalls beschäftigt, sondern die Performance von Apptainer in HPC-Szenarien untersucht. Hierbei hat die Arbeit mehrere Benchmarks durchgeführt \cite[Vgl. S. 2587]{huExploringPerformanceSingularity2019} und nicht wie bei dieser Arbeit die implementierte Containerisierung evaluiert.  


\section{Fazit}

Es gibt bereits eine Vielzahl an Arbeiten, die sich mit Containerisierung befassen, insbesondere auch im Wissenschafts- und HPC-Bereich. In den meisten Fällen wird jedoch der aktuelle Stand der Containerisierung oder die Performance betrachtet. Diese Arbeiten fokussieren sich allerdings meistens eher mit der Feststellung des aktuellen Standes der Containerisierung in der Wissenschaft und HPC \cite{moreauContainersComputationalReproducibility2023}, oder mit der Performance von Containern in HPC-Szenarien \cite{huExploringPerformanceSingularity2019}. In einigen Arbeiten wird sich auch mit den "best practices" für die Containerisierung von Software beschäftigt \cite{fachrudinImplementationAnalysisContainer2025}.

Allerdings gibt es bisher keine Arbeit, welche sich mit der Implementierung eines konkreten Anwendungsfalls für eine HPC-Anwendung beschäftigt und diese im Anschluss mithilfe von Benchmarks evaluiert. Insbesondere gibt es keine Arbeit, welche die Verwendung von Docker Buildx Bakefiles für das Erstellen von Containerimages für HPC-Anwendungen in Betracht zieht.



